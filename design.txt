TODO:
  https://dev.to/techschoolguru/use-grpc-interceptor-for-authorization-with-jwt-1c5h
  https://github.com/MaksimDzhangirov/complete-gRPC/blob/main/lecture15_rus.md
 * implement client
 * makefiles для разных ОС
 * клиент должен распространяться в виде CLI-приложения с возможностью запуска на платформах Windows, Linux и Mac OS;
 * клиент должен давать пользователю возможность получить информацию о версии и дате сборки бинарного файла клиента.
 * добавить github hooks если будет время
 * swagger?

------------------------------------------------------------------------------------------------------------------------
GOPHKEEPER DESIGN
------------------------------------------------------------------------------------------------------------------------
Сервер
------
Два grpc сервиса в одном микросервисе.

TLS сервис

    регистрация, аутентификация и авторизация пользователей;

        Register - записывает пользователя в БД

        Login - возвращает session_token авторизации (думаю попробовать поработать с JWT)

        service Auth {
            rpc Register(RegisterRequest) returns(RegisterResponse);
            rpc Login(LoginRequest) returns(LoginResponse);
        }


----------------------------------------------------------------------------------

    хранение приватных данных;

        буду использовать PostgreSQL, т.к. с ним в основном работал в спринтах
        для миграций буду использовать библиотеку goose (pgx + от автора tern для миграций)
        scany - обертка

    синхронизация данных между несколькими авторизованными клиентами одного владельца;

        на сервере будет воркер пул, похожий на реализацию в shortener,
        чтобы проверять если есть новые данные для синхронизации от клиента и записывать/обновлять их в БД
        сценарий с одним пользователем

    передача приватных данных владельцу по запросу.

    обеспечение безопасности передачи и хранения данных;

        TLS сертификаты совместно с grpc сервером  - credentials package

service Gophkeeper {
    rpc AddData(AddDataRequest) returns(AddDataResponse);
    rpc GetData(GetDataRequest) returns(GetDataResponse);
    rpc DeleteData(DeleteDataRequest) returns(DeleteDataResponse);
    rpc SyncData(SyncDataRequest) returns(SyncDataResponse); // принудительная синхронизация от пользователя
}

ВОПРОС: нужен ли кеш? нет
------
Клиент
------
Будет использовать сгенерированный код от protoc.

--------
Схема БД
--------

+RefreshPassword (reset passsword)

CREATE TABLE IF NOT EXISTS "users" (
    id       text NOT NULL PRIMARY KEY,         // уникальный идентификатор пользователя (uuid)
    login    text NOT NULL UNIQUE,              // логин пользователя уникальный
    password text NOT NULL
);

CREATE TABLE IF NOT EXISTS "data" (
    id          text NOT NULL PRIMARY KEY, // уникальный идентификатор данных (uuid)
    user        text NOT NULL,             // идентификатор пользователя (uuid)
    +FOREIGN KEY REFERENCES
    type        text NOT NULL,
    data        bytea NOT NULL             // буду хранить текущий тип как бинарные данные
);

uuid лучше использовать для postgres типа

ВОПРОС: использование bytea это ок? Второй вариант Large Object feature или нужно хранить данные по другому?

----------
Интерфейсы
----------

Интерфейсы для слоя хранилища:

type UserRepository interface {
	RegisterUser(*model.User) (error)
	GetUserByLogin(string) (*model.User, error)
}

type DataRepository interface {
	AddData(*model.Data) error
	GetDataByUserID(string) ([]*model.Data, error)
	DeleteDataByDataID(string) error
}

Интерфейс для конвертации и инкапсуляции типов данных:

type DataType interface {
    GetType() string
    GetData() []byte
}

------
Модели
------

type User struct {
    id             string  `json:"id"`       // уникальный идентификатор пользователя
    login          string  `json:"login"`
    password       string  `json:"password"`
}

Типы хранимой информации
   пары логин/пароль;
   произвольные текстовые данные;
   произвольные бинарные данные;
   данные банковских карт.

Для любых данных должна быть возможность хранения произвольной текстовой метаинформации (принадлежность данных к веб-сайту,
личности или банку, списки одноразовых кодов активации и прочее).

// типы данных
const (
	DataPassword    = "PASSWORD"
	DataText        = "TEXT"
	DataBinary      = "BINARY"
	DataCard        = "CARD"
	лучше сделать тип DataType string как enum
)

type Data struct {
    id           string  // уникальный идентификатор данных
    userID       string  // идентификатор пользователя
    type         string  // тип данных
    data         []byte  // зашифрованные данные в формате json
}

type password struct {
    description  string `json:"description"`  // произвольная мета информация
    login        string `json:"login"`
    password     string `json:"password"`
}

type text struct {
    description  string `json:"description"`  // произвольная мета информация
    value        string `json:"value"`
}

type binary struct {
    description  string `json:"description"`  // произвольная мета информация
    value        []byte `json:"value"`
}

type card struct {
    description  string `json:"description"`  // произвольная мета информация
    name         string `json:"name"`
    number       string `json:"number"`
    date         string `json:"date"`         // срок действия
    cvv          string `json:"cvv"`
}

Лучшие практики

в конце функции всегда позитивный сценарий
не использовать else
логгеры (zap, zerolog, logrus) - не использовать стандартный log и fmt
логгеры инициализируются в main и передаются в конструкторы всех структур (поле лог)
принимай интерфейсы - отдавай структуры
в config добавить Getters для полей
интерфейсы должны быть объявлены
освобождение ресурса(отмена транзакции и т.д.) сразу после создания
golang project layout /semver (package/internal)
по дефолту не делать ничего публичным (поля структур и функции)
Вызывать s.db.QueryContext методы для БД
антипаттерн определять ctx в структуре
ctx - первй параметр
место инициализации глобальных переменных это  main,  и должны передаваться дальше по стеку
!добавить golangci-lint!

